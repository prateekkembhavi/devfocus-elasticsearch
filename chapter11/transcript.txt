Copyright © 2015. Siteworx, LLC. All Rights Reserved.

It's time to visit an old friend in this chapter of the Siteworx Developer Focus Elasticsearch series.  And no, I'm not talking about me, Jim, Senior Developer at Siteworx.

Quick recap: We've created our pokemon dataset index, type, and fields, bulk indexed the pokemon data, and run a variety of queries on it.  In chapter 6 we added a nested type field named "how_to_find" to the pokemon type fields.  We briefly went over the reason for using nested as opposed to a regular object type, but now it's time to put that nested field to work in

Chapter 11: Nested Queries

In this chapter, we will create a nested query, and revisit the benefits of nested fields and queries.  We will also show how to use a combine a nested query with other queries in a bool query.

As always the setup files for this chapter are linked in the video description.  If you need help with the setup please check out the Chapter 3 video. Standard setup files and script: drop index, recreate it with our type, and bulk index pokemon.  Once that's done, switch to the head plugin and check your counts and index metadata, as usual.  Everything looks good, let's go.

As the Elasticsearch documentation reads, A nested query is a type of query that is executed on nested documents as if they were separate documents, which technicall they are.  That is why the number of docs listed on the overview here is so much higher than the number of pokemon in our system.  Every "how_to_find" entry on a pokemon counts as its own document.  The nested query only focuses on these internal documents and their fields, and when a match is found, the nested document's parent document is returned as a result.

The best way to show the benefits of a nested query is to show the same query being attempted as a regular query.  Let's write a query that should return no results in our dataset.  I am writing a regular bool query that is asking Elasticsearch to return all pokemon that can be found as starters and are in Pokemon Gold.  While there are certainly starter pokemon in pokemon gold, we do not have them in our dataset.  But wait, we still get 3 results, the 3 starters in both pokemon red and blue!  Why is this?  Well, technically they do match our query.  Each has at least one how_to_find with the method "Starter" and at least one with the game "Gold".  How do I write a query that treats each how_to_find as its own document so that when I look for method Starter and game Gold, I get no results?  That's right, a nested query.

Now remember, the only reason I can run a nested query on how_to_find is because I specifically set it as the nested field type when we created our pokemon type.  For example, I can't run a nested query on the "hm" field.  Even though it looks similar in structure to the how_to_find field, it was only set up as the field type of "object" and thus its "hm" values are not treated as separate documents.

So let's convert this query into a nested query.  I am adding the nested query above my regular query because I want to run the exact same query that I have, but only on my nested documents.  Then I set the path, which is the nested field to direct the query at.  In our case, it's how_to_find.  And then I set a score mode.  The score mode is the way the score of the matching nested documents affects the parent document's score.  If my query matched multiple nested documents on one parent document, and I use the default score mode of "avg" or average, it would get the average of the score of both nested documents and add that to the parent's score.  We will go over the benefit of altering the score mode shortly.

Now that my nested query is all set up, let's run it and I get no results.  Do you remember why?  Because none of the pokemon in our dataset are starters in pokemon gold.  Now to actually get some results, let's run the nested query to get all starter pokemon from pokemon blue.  Now I get the 3 I expect, and as you see, each of them has a "how_to_find" nested document that contains both Starter and Blue.  Just to keep showing some examples, let's check for all pokemon obtained through world events in pokemon blue.  And you'll see all of these have a method Event, game Blue how_to_find match.  One more is Time Capsule in blue, which is zero because the time capsule method only exists in Silver and Gold.  So if we change our game to gold again we get 17 generation 1 pokemon who can be obtained by time capsule in pokemon gold.  If you're curious, try running all of these queries as non-nested queries, and you will mostly likely see very different result sets.

The JSON for a nested query is pretty heavy, but that doesn't mean it can't be combined with other queries!  Let's change our nested query to get all pokemon that can only be obtaineg through trade in Pokemon Red.  Now I want to filter this result set to only get Fire Pokemon that can only be obtained through trade in Pokemon Red.  I can't just add to the nested query's bool query, because that query only knows about the how_to_find fields.  So We will have to put the entire nested query into the list of Must or Filter clauses of a bool query.  And now that I've wrapped the nested query in a bool query, I can add my Fire type filter to the list of must or filter clauses as well.  And now our results only have 3 pokemon, Vulpix, Magmar, and Ninetales, that are all of type Fire, and have at least one how_to_find that matches the Trade method and game of Red.  

Now that we have a bool query that includes a nested query, let's revisit the score mode attribute.  Let's go into our nested query and remove the how_to_find.game and change the method to Catch.  Now when I run the query, the matching how_to_find documents that match the method Catch all have the same score, so the average score is the same as one match.  Obviously this doesn't affect the result order much as each result has at least one how_to_find set to catch.  But now check out Ponyta.  Ponyta has 4 Catch methods, yet it's only the third on the list.  What if we want a result like this higher than the others?  If we do, we can use the score mode of "sum" instead, which adds the score of all matching nested documents to the parent's score.  So when I make that change and run the query, now Ponyta is at the top of my list because it had the most "Catch" matches out of the result set.  The other options are max which only adds the highest scoring matching nested document to the parent's score, min which only uses the lowest, or none which means the scores of the nested documents won't affect the parent document's score at all.  But at least in this example, the only major difference is between avg and sum.

That sums up our chapter on nested queries.  In this chapter, we learned how to write nested queries and run them against nested type fields.  We also combined our nested query with other queries in a bool query.  We then went into detail about the score mode attribute and how it can affect the result order.

In the next chapter, we will learn about aggregations, formerly known as facets, and how we can use them to offer valuable information to the end user, such as how many results of your current query have a specific type or catch method.

I'm glad we were finally able to come back to nested queries in the Siteworx Elasticsearch Developer Focus Series.  After all, learning them is the reason we made how_to_find the nested type in the first place.  See you next chapter! This is Jim, have a great day.