Copyright © 2015. Siteworx, LLC. All Rights Reserved.

Ladies and gentlemen, I present to you, the Siteworx Developer Focus Elasticsearch Series.  You know the drill: Jim, Senior Developer, host of the show.  Let's get going, shall we?

To quickly recap, so far we have set up our index and type along with the type's fields.  We've also bulk indexed our data and ran some simple queries upon it.  Also, our dataset is Generation 1 Pokemon.  Now that our data is all set up nice and pretty, we can turn our attention primarily to querying, and the features that come with it.  Let's start with some simple but extremely useful features in

Chapter 7: Sorting and Pagination

In this chapter, we will learn how to sort our data using the fields in the pokemon type, and how to set the direction of the sort.  We will also learn how to only return certain fields in our results.  Finally, we will learn how to paginate our results so we can look past the default 10 that elasticsearch returns.

The setup files for this chapter are linked in the video description.  If you have no idea what to do with these files, please check out the Chapter 3 video.  This week we are back to the normal setup script, where it drops our index, then recreate it with our pokemon type.  It then bulk indexes all of the pokemon data we currently have, which is the first 18 Generation 1 pokemon.  As you can see, our pokemon have been indexed.  Remember that this number is larger than 151 because we added the "how_to_find" nested type, and this count includes those values we added to the first 18.  Finally, we see our index metadata set up with all of the fields we've created in the past.  Alright, looks good, let's play.

To keep this simple, our query is going to be a match all query.  Remember, this will return to us all of the documents of the Pokemon type.  Note that they all return in the order that we indexed them, which is by ndex number.  Let's sort them by their names instead.  The sort configuration will be built at the same level as the query configuration in the JSON request.  Here I am setting my config to sort on the name field, and I am setting the direction to ascending.  Since name is a string field, ascending means ordering the results by their name from A to Z.  You can see the As here.  Now I will change the query to order it descending, which reverses the order to be from Z to A, and we get the Z pokemon first, followed by others in reverse alphabetical order.  Lucky for us, every pokemon document in our bulk index has at least a name and number.

Note how the sort is listed in each result, and how this particular one is all lowercase.  That's because the sort value is the actual tokenized value of that field in the index.  If we wanted to sort on the not_analyzed, or untokenized version of name, we can run our sort on name.raw instead.  We also set up a few other fields with raw, untokenized values, such as type.  See how these Pokemon with type Bug are first in the list?

Now I don't feel like constantly scrolling past all of our data about each pokemon in order to see which results I am getting.  So I am going to set the fields configuration for this request.  The fields config allows you to limit the fields that are returned in each result's source.  We are going to only show the name and type of each of our pokemon.  And now that our query has been run again we can more clearly see how our results are ordered by their type.  An interesting thing to note is that for the pokemon that have two types, such as Bug and Poison, it is using the lowest value to sort upon.  Lucky for us, we can change this if needed.

So far we have been using the shorthand way to write sort configurations, but now let's set this one up using the formal way, with a child object that contains the "order" field.  Now I'm also going to add a Mode to the sort and set it to "Max".  This means it should use the highest value available of the field "type.raw" on each document in the results to sort upon.  Now we see that the pokemon that had both types Bug and Poison are no longer next to the other Bug types, but will be later in the results where alphabetically Poison would make sense.  Unfortunately they are not in the first 10 results, but if we check out Bulbasaur, you can see the sort value is set to Poison instead of Grass.  Another option is "avg" or "average" which takes the average of a field with multiple values and uses that as its sort value.  As you can see it doesn't really do much for string fields, but is very useful on number fields with multiple values.

Another fun feature of sorting is the ability to sort on multiple fields.  How this works is Elasticsearch will sort on the first field as the primary, and then on the second as secondary, and so on.  I decided I want to have all pokemon that have evolutions appear first on the list, so I am converting the sort config into an array, and adding the "has_evolution" field as my primary sort field and type.raw as my secondary.  Since Elasticsearch's sorting treats boolean field values true and false as 1 and 0, the ascending direction will put False first, while Descending will put True first.  And you can see here in the sort values that the 1 for true is first, and second is the type.

That is all we have today for basic sorting of our content.  Now let's paginate our data so we can check out our results past the first 10.  I am going to simplify our fields to just ndex and name and sort to be by ndex ascending, so that we can focus on our pagination fields: size and from.  Size is the size of the result set that we get back.  See when I set the size to 2 I only get 2 results back?  Pretty self-explanatory.  Now I am adding the "from" configuration.  The From configuration tells the index what position in the result set to begin pulling results from.  It is important to note that this, like the results, is zero-based, which means sending a From of 0 will start the result set with our first pokemon, Bulbasaur, and if I set it to 1, I get Ivysaur.  Now let's go deeper in and set our From to 15.  Lucky for us, our ndex count pairs well with our result count, so you can see that from 15 and size 5 means we will get pokemon numbers 16 through 20.

This concludes chapter 7, which was the first official chapter entirely focused on querying.  In this chapter, we set up sort configurations based on fields, and told the index which direction to sort the field using the Order property.  We also set up multiple sorts on a single query.  Finally, we learned how to paginate our results using the size and from configurations.

In the next chapter we will learn about some more Filter, or Term-Level, Queries such as the Wildcard and Exists queries.

The querying fun has just begun in this episode of the Siteworx Elasticsearch Developer Focus series.  Thanks for sticking around, you won't regret it.  This is Jim, have a great day.