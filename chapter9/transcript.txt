Copyright © 2015. Siteworx, LLC. All Rights Reserved.

I hope you're ready for one of the more intense chapters of the Siteworx Developer Focus Elasticsearch Series.  Don't worry, let me, Jim, Senior Developer, explain it to you to the best of my ability.

Recap time!: Index, type, and fields all set up.  Data is indexed and we've run all sorts of queries, sorted, and paginated.  We love Gen 1 Pokemon and don't plan to stop using them yet.  Now, it's time for all of our queries to join forces for us to create

Chapter 9: Bool Queries

In this chapter, we will learn about the primary compound query used in Elasticsearch, the Bool query.  While learning about the Bool query, we will also discuss the difference between querying using the query context versus the filter context and the benefits of using the filter context where we can.

The setup files for this chapter are linked in the video description.  No idea what to do with them? Check out the Chapter 3 video. Standard setup files and script: drop index, recreate it with our type, and bulk index pokemon.  We still only have detailed data on the first 18, but that's still all we need.  Don't forget to check your counts and index metadata to make sure everything got set up properly.  Look good? Great, let's start.

Before we get into the Bool Query, I think it's important to distinguish the two contexts that a query can use: the query context and the filter context, and why we would want to use the filter context in our queries.  

As Elasticsearch's documentation states, the best way to look at these two contexts is by asking yourself "What am I trying to accomplish?".

If your query's goal is to test "how well" a document matches your query, you will want to use the query context.  The query context cares about score and will rate a document higher in the result set if it matches your query "better" than other documents.  Most keyword or full text queries depend on this type of scoring to help the user find the best matching result for their query.

If your query's goal is to simply obtain all documents that match your query, you're better off using the filter context.  This is for situations where you don't necessarily care about the score of the results, you just want the set of documents that match specific criteria.  Examples of filter context queries on our Pokemon dataset would be "all pokemon where has_evolution is true" or "all Pokemon of type 'Fire'".  The benefit to using the filter context is that Elasticsearch will cache frequently used filters, which can speed up overall performance.  The filter context is completely optional, and it's up to the developer to choose to use it.  We have actually run plenty of queries in our series that could be written in the filter context, but we kept them as queries for teaching purposes.

The reason I am bringing up the difference in these contexts now is because of how easy it is to distinguish either type when writing a Bool query.  Now let's move onto the Bool query itself.

The Bool query is a way to combine multiple queries into a single query, and thus a single request.  We can't just give it a list of queries to combine though, we need to tell it how to handle each inner query, or clause, we provide.  We can sort these clauses into 4 types: "must", "filter", "should", and "must_not".  Let's set up a an example query to explain how each of these clauses work.

Here I am setting up a regular match query that is pointing to the type field.  I want to get all Pokemon that are of type Grass and Poison, so I am going to do a match on Grass Poison.  As you can see in the results, the Pokemon that are both Grass and Poison score the highest in my query, but my result set also includes Pokemon that have either Grass or Poison as their type.  This is an example of a query using query context, as the score definitely boosts the results I want to the top, but it doesn't eliminate the ones that don't match perfectly.  I need a way to make sure I only get results that have both the Grass and Poison types.  Here is where we can begin with our Bool query.

I'll begin by converting my query into a Bool query with a list of Must clauses.  The "must" clauses are required in the matching documents and contribute to their overall score.  I am going to move my query into a must clause and then split Poison into its own clause.  See how I went from 6 to 3 results, and now my results have both Grass and Poison set as types?

You'll also notice that I am running two query context queries where we could definitely be running filter context queries.  The type field is a very "term-level" field, seeing as its values are short and we generally query on the entire value.  Also, we really don't need scoring to only get pokemon that are of both type Grass and Poison.  So let's convert these must clauses into filter clauses, and because we have the exact data available, turn these into term queries that look at type.raw instead.  The "filter" clauses are also required in the matching documents, but don't contribute to the score (as we mentioned earlier, filters don't care about score).  You'll notice that the result set remains the same, but behind the scenes this part of the query is now cachable.

One of the benefits of a Bool query is its ability to combine multiple types of clauses.  So now I will leave my type filter clauses, and add a new must clause that does a full text search for Venusaur.  Now I get 2 results back, as Ivysaur has Venusaur set as its evolution.  Now our query requires the matching pokemon to have both type Grass and Poison, and the term Venusaur somewhere in its content.

The "should" clauses should, but may not definitely, appear in the matching documents.  There are usually multiple "should" clauses if they are used at all.  You can think of "should" clauses as "OR" and "must" clauses as "AND" when typing a keyword search query.  So now I am going to remove my Grass type requirement, and replace my must clause with two should clauses directed at the how_to_find method field.  My goal now is to find all Pokemon that are of type Poison, that should be found using either the Starter or Catch method.  You'll notice that all of our results that match either (or both) should clauses are scored higher, but at the very bottom we will still find Ivysaur and Venusaur, who don't match our how_to_find clauses.  How is this possible?  It's because we at least have one must or filter clause that trumps the should clauses.  So even though Venusaur SHOULD match one of those two methods, ultimately it appears because it matches the Poison type filter.  It just scores lower than the others.  And now if we remove the Poison type filter requirement (and change our size to 20 to get all 11 results), you'll see that Venusaur is nowhere to be found.  All of the results now can either be picked as a starter pokemon, or caught in the wild.

Just for fun, let's still revisit our initial goal for the should clause.  We want to get all pokemon of type poison that can either be caught or picked as a starter.  How do we write this query?  We can accomplish this by nesting bool queries.  First, let's add our Poison type filter clause back and rerun our query.  We get 6 results, but we know from before that 2 of them are not caught or starter pokemon.  Next, we have to convert the should to a must.  But we shouldn't run this, because it will only return pokemon that can be caught AND be starters.  But we still need Elasticsearch to treat our should like a must.  What we need to do iscreate a child bool query that only contains the should clauses, and put that entire new bool query as one of the must clauses of the parent bool query.  This can get confusing, but it can help to think about it as if you are running two queries.  The first is the child bool query, which gets us all pokemon that are either starters or caught in the wild.  We then run the rest of the parent query on ONLY that set of results, which gets us the actual 4 pokemon that match our query parameters.  I have run into situations where I have to write queries like this quite often in the past, so I wanted to make sure I went over this use case in this series.

Finally, we have the "must_not" type, which are clauses that the matching documents should not match.  Just to show a few examples, I am going to leave our Poison type filter set, and tell the query that the result pokemon must not have an evolution.  I can also tell the query to get all Poison pokemon, but only return those that are not also Grass pokemon.  And you'll see only the Bug and Poison Pokemon are left.

This concludes our chapter on bool queries.  In this chapter, we learned about the two contexts a query can use, the query and filter contexts.  We also used those contexts when creating Bool queries.  We also learned about the different clauses available to us in Bool Queries: Must, Filter, Should, and Must Not.  Finally, we learned how to nest our bool queries.

In the next chapter we will learn about the Query String query, which lets us create queries using Elasticsearch's Query syntax.

Phew, that was a pretty heavy chapter of the Siteworx Elasticsearch Developer Focus series.  But I personally believe it to be one of the most useful so far.  But there's still plenty more to come, so come back soon!  Thanks, this is Jim, have a great day.