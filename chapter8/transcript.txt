Copyright © 2015. Siteworx, LLC. All Rights Reserved.

Things are getting pretty interesting here at the Siteworx Developer Focus Elasticsearch Series.  Let me, Jim, Senior Developer here at Siteworx, tell you all about it.  Take a seat, we're going to be here for a few minutes.

Quick Recap time: we've set up an index, type, and fields.  We bulk indexed our data and we've run a variety of queries.  We've also sorted and paginated our results.  Dataset: Gen 1 Pokemon.  Now, we'll be continuing to learn some more fun ways to query in

Chapter 8: Term-Level Queries

In this chapter, we will learn what makes a query a term-level query, and also run a few of them including the Missing, Exists, Prefix, and Wildcard queries.

The setup files for this chapter are linked in the video description.  If you have no idea what to do with these files, please check out the Chapter 3 video. We're still using our standard setup files and script, which drops our index, recreates it with our pokemon type, and bulk indexes our pokemon.  We still only have detailed data on the first 18, but that is all we will need in this chapter.  Don't forget to check your counts and index metadata to make sure everything got set up properly.  Mine looks good, so let's get moving.

Before we get into the querying, let me define what a Term-Level query is.  The best way to explain this is to also discuss its counterpart: the full text query.  In Elasticsearch, queries can be catagorized as either a full text query or a term level query.  Simply put, and from the Elasticsearch documentation, A full text query analyzes the query string before executiving, while a term level query deals with exact terms.  We consider a query "Term-Level" when it does not involve analysis in any way.  They are usually run on non-tokenized fields that have shorter, one or two word values, such as the name.raw, type.raw, and evolution.raw fields in our dataset.  We have used examples of both in the past.  Early on, we used the Match query, which is a full text query that will score documents based on the analysis and tokenization of said document, and determine which documents match the query best.  The higher the score, the closer to the top the result will be.  We've also used the Term query, which is a term level query, in order to get results where a non-analyzed field value matched an exact query.  Each exact match will give the same score across all matching documents, and no analysis or tokenization is involved.

Now that we understand what a Term-Level query is, let's look at a few of them.  The first one we will look at is the Missing query, which is used to query the index for all documents where a specific field is missing or null.  You'll see here I am wrapping this query using a constant_score query, which is me telling Elasticsearch not to score the results, because they will all not have this field and the what order the results come back in doesn't matter to me.  I am going to write this query to return to me all pokemon without an HM field set.  Since we only have 18 pokemon that could potentially have this field set, our result set for this query will have at least 133 results.  But since we have 138 that means 5 out of our 18 do not have any HMs.  You'll notice as a scroll that each result has the score of 1, and that all of the results are missing the HM field.

Similar to the Missing query, we have the Exists query.  Just like the Missing query, false or a blank string does not mean null, so those will match an Exists query.  For example, if I query for all pokemon that have "has_evolution" set, I will get the first 18, because they either have "true" or "false" set, and false is treated as a value, not null.  Let's also check our HM field again and we can see that the 13 have HMs.  This compliments our 5 results from our Missing query.

An interesting note about the Missing and Exists queries is that they can be run on tokenized fields, but they are still considered Term-Level queries because they have do not do any analysis.  The next two queries, on the other hand, can only be run on non-tokenized fields.

The prefix query will return all results where the field being queried has a value that begins with the characters queried.  It is the ideal query to use when you are setting up a type-ahead in an input field on your site or application, that suggests values as the user types in characters.  Let's query our name field for all pokemon whose names begin with Ch.  As you can see, querying directly on name gives us no results, because name is tokenized.  I can simply change the query to point to name.raw in order to get the results we want.  And we get Charmander, Charmeleon, Charizard, and Chansey, all beginning with Ch.

The prefix query is basically a shortcut for our next query, the Wildcard query. We could write a wildcard query of Ch* and we would get the same results.  But the wildcard query allows us to place the wildcard in other parts of the query.  We can use an asterisk, which matches 0 or more characters, or a question mark, which matches any single character.  In this query, I am putting the wildcard at the beginning and querying for all Pokemon whose names end in earow.  And you'll see, our result set consists of Spearow and Fearow.  We can also place the wildcard right in the middle.  Here I am running a query on all names that begin with Tentac and end with an L.  And that gets us Tentacool and Tentacruel.

Note that the closer to the beginning of the string the wildcard is, the longer these queries will take to run.  Our dataset is small enough that it won't affect us, but in much larger datasets it could lead to significant slowness.

This concludes our chapter on term level queries.  In this chapter, we learned the difference between a full text query and a term level query.  We also went over examples of term-level queries, such as the Missing, Exists, Prefix, and Wildcard queries.

In the next chapter we will learn about the valuable Bool Query, and how we can use it to combine multiple queries.

Thanks for sitting through all of that Siteworx Elasticsearch Developer Focus series chapter.  Feel free to stand up, stretch, take a break, but don't go anywhere, because we still have more in store for you.  This is Jim, have a great day.