Copyright © 2015. Siteworx, LLC. All Rights Reserved.

If you thought the last chapter of the Siteworx Developer Focus Elasticsearch series was intense, prepare to ease yourself into this fun chapter.  I, Jim, Senior Developer at Siteworx, am especially looking forward to what's next.

If you are just joining now, here's what we've done so far.  We have an index, type, and fields set up, and a way to bulk index our content.  We've queried from match to bool, sorted, and paginated.  We are using Generation 1 pokemon as our dataset.  Last chapter we wrote a bool query which is a large, structured JSON, and the most proper, efficient, and accurate way to combine multiple queries in Elasticsearch.  Now let's do the same thing but less formally using 

Chapter 10: Query String Queries

In this chapter, we will take many queries we've written in the past and write them in simplified Query String Queries.  We will learn the attributes available for Query String Queries and about Elasticsearch's Query String Syntax.

As always the setup files for this chapter are linked in the video description.  If you need help with the setup please check out the Chapter 3 video. Standard setup files and script: drop index, recreate it with our type, and bulk index pokemon.  I have a big announcement in regards to our setup files: Starting in this chapter, our Generation 1 Pokemon dataset is complete.  All 151, plus Missingno., have their data fully entered in our pokemon bulk json file, and will be available for us to query upon.  It took me a few hours, but we should now start seeing much better results to our queries.  Once the bulk is done, check your counts (which will be much higher due to the additional how to find nested documents) and index metadata, and we are ready to roll.

Throughout the series, we have written plenty of queries using the JSON structure that Elasticsearch expects for each.  Using the appropriate query types and building out the full query really does help Elasticsearch efficiently get the correct results.  But today we are going to look at querying as an end user.  You could build a form for your end user to fill out, and then build your query based off of those entries.  This is usually the safest way as the common end user may not know how to write advanced search queries.  But say you have a few administrative users who want to be able to write their own custom queries.  Should we allow or even want them to write a full JSON query and submit it straight to Elasticsearch?  Probably not.  Fortunately for us, there is the Query String Query.  This query is a way to write a complex query without needing to break it out into multiple queries or use a bool query, or ask the user to write an actual JSON Elasticsearch request.

Here I have set up the JSON format for a Query String query.  Inside it, we have the query attribute, which is where we will write our queries using Elasticsearch's query string syntax.

But before we run any queries, let me explain some other possible attributes.

One of the options is default_field, which allows us to focus the query on a specific field, but by default it is set to _all, or every field in a document.  So if I wanted the query to only look at name I could add the default_field set to name. Now I'm going to query for venusaur and I get only venusaur back.  Note that when we usually do a match query for venusaur we get ivysaur back due to it having venusaur as its evolution, but because im only looking at the name field, ivysaur is omitted

Another is "fields" which allows us to query multiple specific fields.  It also allows us to set a boost on specific fields so that if a match is found on that field, its document will get a higher score.  So I can change my query to look at name and evolution but you'll see Ivysaur is my first result.  I can add a boost to the name field to give a match in name a higher score, and now we get venusaur first.  We can also use an asterisk to tell the query we want to query on all inner fields of an object, such as using hm.* to include hm.id and hm.name.  But in this chapter we are going to query on all fields by default to show the power of the query string syntax.

We can also set the default_operator to be something other than OR, such as AND.  To show this, I can type in grass poison as my query and I will get all pokemon with grass or poison mentioned.  But if I change my default operator to AND I get less because I am only getting pokemon with both grass and poison mentioned. But today we will leave it as its default, OR.  This is beneficial to us when we use the query string syntax, as you will see soon.

There are plenty of other attributes available besides these common ones.  Please check the Elasticsearch Documentation for Query String Query for more information.  There's also a link in the video description.

So let's move into the query string syntax. 

Let's start with a very simple query, "flying".  This will act like a match query and get all pokemon that have the word flying anywhere in their content.  Chances are in our content it will only be found in type.  Now let's add fire, since charizard is fire and flying.  Since the default operator is OR, we end up with more results than we had with just flying.  Fortunately, the Query String query accepts Boolean operators.  I can add a boolean operator, such as a "+" sign before each search term, and I'll only get pokemon with both Fire and Flying types, such as Charizard or Moltres.  I can also use a minus sign before fire to get all pokemon that have the flying type but do not have the fire type, which will remove the all fire pokemon including the previous two from our results.

Now I know what you're thinking, what happens when those search terms are in more than one field and I only want to query on type?  Not a problem, as we can see by recreating one of our bool queries from chapter 9, which was to get all pokemon that are both grass and poison type.  I can make sure I only query a specific field by writing it before the search term seperated by a colon, like so: +type:grass +type:poison.  Each term can be from a different field as well, such as +type:poison -hm.name:cut.  But what if I wanted to query every field under hm?  I would have to write this as hm.\*:cut, and escape the * as it is a reserved character.  Since I am using the head plugin, I have to double escape it like you see in the video.  Please see the documentation for a full list of reserved characters that need escaping in the query string syntax.

Remember that as long as we aren't pointing at the non-analyzed, or .raw, fields, none of these queries will be exact.  If we want to make sure we are querying the exact value, we can use the .raw fields in these queries.  This means we also need to properly capitalize the values we're querying, like so.

We can also do range queries within this syntax.  Let's get all of our Poison type pokemon that are from ndex 65 to 75 as an example.  And you can see we can find 5 poison pokemon in this range.

We can also group our queries, similar to our nested bool query in chapter 9, which was to get all Poison type pokemon that are either starters or could be caught.  Do you remember this massive query?  We can completely recreate that complex bool query that included the nested how_to_find should bool query in one query string using the proper syntax, which is +how_to_find.method(starter OR catch) +type:poison.  Note that the order may be different because I used non-exact query terms.  Type does have a raw so if I change this to look at type.raw we should get the exact same result set.  One thing I can't affect with the Query String query is the scoring.  In our nested bool query, I was able to put the type.raw query in filter context, and I have no way of doing that here.  So even though this is a faster and simpler option, it won't have the same caching capabilities of the filter clauses of the bool query.

Wildcards can also be included, such as our chapter 8 example for all pokemon whose names begin with Ch.  We can just write name:Ch*.  This is a unique situation because the wildcard query itself needs to be run on name.raw.  In the query string syntax, it lowercases your query and runs it across the tokenized value or name, which is not as exact as the actual wildcard query and may perform slower.

Another powerful capability is being able to boost parts of our query.  Let's create this query: type:Poison type:Bug type:Grass.  This gets us all pokemon that have types of either Poison, Bug, or Grass.  We see Paras up top here with both types Bug and Grass.  So let's say we want the same query, but we want the Poison pokemon to show up first.  We can add a boost to the type:Poison part of the query, and boom, the Poison pokemon are showing up first.

Finally, we can also use missing and exists queries in this syntax!  So say we wanted all pokemon that don't have an evolution set, we can simple write out _missing_:evolution, and we're done!  We can also write _exists_:evolution to only get pokemon with an evolution set.

The Query String query and its syntax are incredibly useful not only to quickly query your index, but also make it easier to allow an end user of your site or application to also run complex queries without needing to write complex JSON object such as in our chapter 9 boolean queries.  Also, it's important to remember that while in our video these looks pretty accurate, its always ideal to write out a full proper query when possible to assure accuracy and efficiency on much larger data sets.

That's about all the time we have for this video.  In this chapter, we learned about quick and easy Query String Queries, including the attributes we can use to modify them, as well as the syntax we can use to run fairly complex queries in a single line.

In the next chapter, we will finally learn about nested queries.  Nested queries let us filter documents based on specific nested type fields on our documents.  In our case, they will be run on the how_to_find nested objects.

I truly hope you got a lot out of this episode of the Siteworx Elasticsearch Developer Focus Series.  I had a great time converting our old queries into Query String queries, and I hope you did too.  See you next time.  This is Jim, have a great day.